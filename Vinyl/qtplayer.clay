import cocoa.*;
import cocoa.qtkit.*;
import random.*;
import sqlite.*;
import Vinyl.library.*;
import Vinyl.library.datasources.*;
import libc;

record StoppedState ();

enum PlaylistMode { Playing, Paused }

variant TrackOrder = Vector[SizeT] | Range[SizeT];

overload index(o: TrackOrder, n) = match(o,
    Vector[SizeT], vec => vec[n],
    Range[SizeT],  ran => ran[n],
);

sequentialTrackOrder(trackCount)
    = TrackOrder(range(trackCount));

[S | LValueSequence?(S) and RandomAccessSequence?(S) and SizedSequence?(S)]
private _shuffleTrackOrder(s: S, trackNumber) {
    for (i in reverseRange(size(s))) {
        var j = libc.random() % (i+1);
        swap(s[i], s[j]);
        if (j == trackNumber)
            trackNumber = i;
        else if (i == trackNumber)
            trackNumber = j;
    }
}

shuffledTrackOrder(trackCount, trackNumber_) {
    var trackNumber = trackNumber_;
    var order = Vector[SizeT](range(trackCount));
    _shuffleTrackOrder(order, trackNumber);
    // always put the current track first
    if (trackNumber != 0)
        swap(order[trackNumber], order[0]);

    return TrackOrder(move(order));
}

overload shuffledTrackOrder(trackCount) {
    var order = Vector[SizeT](range(trackCount));
    _shuffleTrackOrder(order, 0);

    return TrackOrder(move(order));
}


record PlaylistState (
    mode: PlaylistMode,
    trackOrder: TrackOrder,
    trackNumber: SizeT,
    libraryView: LibraryView,
    movie: Retained[QTMovie],
    tracks: Vector[PlaylistTrack],
);

[I | Integer?(I)]
overload PlaylistState(mode: PlaylistMode, track: I, library: Pointer[Library], view: LibraryView, shuffle?: Bool)
{
    var returned = PlaylistState(
        mode,
        sequentialTrackOrder(SizeT(0)),
        SizeT(track),
        view,
        Retained[QTMovie](),
        Vector[PlaylistTrack]()
    );

    for (row in libraryViewStatement(library^.db, String(), view))
        push(returned.tracks, rowRecord(row, PlaylistTrack));

    if (shuffle?) {
        returned.trackOrder = shuffledTrackOrder(size(returned.tracks), SizeT(track));
        returned.trackNumber = 0;
    } else
        returned.trackOrder = sequentialTrackOrder(size(returned.tracks));

    return move(returned);
}

setSequentialTrackOrder(ps: PlaylistState) {
    ps.trackNumber = ps.trackOrder[ps.trackNumber];
    ps.trackOrder = sequentialTrackOrder(size(ps.tracks));
}

setShuffledTrackOrder(ps: PlaylistState) {
    var realTrackNumber = ps.trackOrder[ps.trackNumber];
    ps.trackOrder = shuffledTrackOrder(size(ps.tracks), realTrackNumber);
    ps.trackNumber = 0;
}

variant PlayerState = StoppedState | PlaylistState;

overload selector(static #"state") = PlayerState;
overload selector(static #"setState:") = Void, PlayerState;
overload selector(static #"handleMovieDidEndNotification:") = Void, NSNotification;
overload selector(static #"handleMovieLoadStateDidChangeNotification:") = Void, NSNotification;
overload selector(static #"playLibrary:view:trackNumber:") = Void, Pointer[Library], LibraryView, SizeT;
overload selector(static #"resume") = Void;
overload selector(static #"pause") = Void;
overload selector(static #"stop") = Void;
overload selector(static #"previousTrack") = Void;
overload selector(static #"nextTrack") = Void;
overload selector(static #"shuffle") = Bool;
overload selector(static #"setShuffle:") = Void, Bool;
overload selector(static #"repeatMode") = RepeatMode;
overload selector(static #"setRepeatMode:") = Void, RepeatMode;
overload selector(static #"playerState") = Pointer[PlayerState];

enum RepeatMode { NoRepeat, RepeatAll, RepeatOne }

alias PlayerStateDidChangeNotification = NSString(#"VinylPlayerStateDidChangeNotification");

record Player = newClass(NSObject,
    InstanceVars(
        state: PlayerState,
        volume: Float,
        shuffle: Bool,
        repeatMode: RepeatMode,
    ),
    ClassMethods(),
    InstanceMethods(
        (#"init", self => initObjectWith(self, #"init", self => {
            self^.state <-- PlayerState(StoppedState());
            self^.volume = 1.0f;
            self^.shuffle = false;
            self^.repeatMode = NoRepeat;

            NSNotificationCenter.defaultCenter().addObserver_selector_name_object(
                self,
                selectorHandle(#"handleMovieDidEndNotification:"),
                QTMovieDidEndNotification,
                nil()
            );
            NSNotificationCenter.defaultCenter().addObserver_selector_name_object(
                self,
                selectorHandle(#"handleMovieLoadStateDidChangeNotification:"),
                QTMovieLoadStateDidChangeNotification,
                nil()
            );
            return self;
        })),
        DeallocInstanceMethod(),
        ...PropertyInstanceMethods(#state, PlayerState),

        (#"handleMovieDidEndNotification:", (self, notification) => {
            match(self^.state,
                StoppedState,  stopped => { },
                PlaylistState, playlistState => {
                    if (is?(playlistState.movie, notification.object())) {
                        if (self^.repeatMode == RepeatOne) {
                            playlistState.movie.stop();
                            playlistState.movie = nil();
                            self.resume();
                        } else
                            self.nextTrack();
                    }
                }
            );
        }),
        (#"handleMovieLoadStateDidChangeNotification:", (self, notification) => {
            match(self^.state,
                StoppedState,  stopped => { },
                PlaylistState, playlistState => {
                    if (is?(playlistState.movie, notification.object())
                        and playlistState.movie.attributeForKey(QTMovieLoadStateAttribute)
                            == QTMovieLoadStateError
                    ) {
                        if (self^.repeatMode == RepeatOne)
                            self.stop();
                        else
                            self.nextTrack();
                    }
                }
            );
        }),

        (#"playLibrary:view:trackNumber:", (self, library, libraryView, trackNumber) => {
            self.stop();
            self^.state = PlayerState(
                PlaylistState(Paused, trackNumber, library, libraryView, self^.shuffle)
            );
            self.resume();
        }),

        (#"resume", self => {
            match(self^.state,
                StoppedState,  stopped => { },
                PlaylistState, playlistState => {
                    var realTrackNumber = playlistState.trackOrder[playlistState.trackNumber];
                    if (nil?(playlistState.movie))
                        playlistState.movie = movieForFileName(
                            self,
                            playlistState.tracks[realTrackNumber].filename
                        );
                    playlistState.movie.autoplay();
                    playlistState.mode = Playing;
                    NSNotificationCenter.defaultCenter().postNotificationName_object(
                        PlayerStateDidChangeNotification, self
                    );
                }
            );
        }),

        (#"pause", self => {
            match(self^.state,
                StoppedState,  stopped => { },
                PlaylistState, playlistState => {
                    playlistState.movie.stop();
                    playlistState.mode = Paused;
                    NSNotificationCenter.defaultCenter().postNotificationName_object(
                        PlayerStateDidChangeNotification, self
                    );
                }
            );
        }),

        (#"stop", self => {
            match(self^.state,
                StoppedState,  stopped => { },
                PlaylistState, playlistState => {
                    playlistState.movie.stop();
                    self^.state = PlayerState(StoppedState());
                    NSNotificationCenter.defaultCenter().postNotificationName_object(
                        PlayerStateDidChangeNotification, self
                    );
                }
            );
        }),

        (#"previousTrack", self => {
            match(self^.state,
                StoppedState,  stopped => { },
                PlaylistState, playlistState => {
                    // XXX start from beginning/previous track behavior
                    playlistState.movie.stop();
                    playlistState.movie = nil();
                    if (playlistState.trackNumber > 0)
                        playlistState.trackNumber -= 1;
                    else if (self^.repeatMode == RepeatAll)
                        playlistState.trackNumber = size(playlistState.tracks) - 1;
                    self.resume();
                }
            );
        }),

        (#"nextTrack", self => {
            match(self^.state,
                StoppedState,  stopped => { },
                PlaylistState, playlistState => {
                    playlistState.movie.stop();
                    playlistState.movie = nil();
                    if (playlistState.trackNumber < size(playlistState.tracks) - 1) {
                        playlistState.trackNumber += 1;
                        self.resume();
                    } else if (self^.repeatMode == RepeatAll) {
                        playlistState.trackNumber = 0;
                        self.resume();
                    } else
                        self.stop();
                }
            );
        }),

        ReaderInstanceMethod(#volume, Float),
        
        (#"setVolume:", (self, volume) => {
            self^.volume = volume;
            match(self^.state,
                StoppedState,  stopped => { },
                PlaylistState, playlistState => {
                    if (not nil?(playlistState.movie))
                        playlistState.movie.setVolume(Float(volume));
                }
            );
        }),

        ReaderInstanceMethod(#shuffle, Bool),
        (#"setShuffle:", (self, shuffle) => {
            self^.shuffle = shuffle;
            match(self^.state,
                StoppedState,  stopped => { },
                PlaylistState, playlistState => {
                    var trackNumber = playlistState.trackOrder[playlistState.trackNumber];
                    if (shuffle)
                        setShuffledTrackOrder(playlistState);
                    else
                        setSequentialTrackOrder(playlistState);
                }
            );
        }),

        ...PropertyInstanceMethods(#repeatMode, RepeatMode),

        (#"playerState", self => &self^.state),
    ),
);

record QTMovieError (error: NSError);
instance Exception = QTMovieError;

movieForFileName(self, name) {
    var error = nil(NSError);
    
    var movie = QTMovie.movieWithAttributes_error(makeNSDictionary(
        QTMovieOpenForPlaybackAttribute, true,
        QTMovieFileNameAttribute, name,
    ), &error);

    if (nil?(movie))
        throw QTMovieError(error);

    movie.setVolume(self^.volume);

    return movie;
}
